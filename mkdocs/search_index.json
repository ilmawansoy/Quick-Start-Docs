{
    "docs": [
        {
            "location": "/",
            "text": "Welcome to KataDocs\n\n\nIntroduction\n\n\nKata Command Line Interface (Kata CLI) is a tool for creating bots with\nKata Machine Learning (Kata ML) which suited with Natural Language Processing (NLP) technology.\nKata CLI also helps managing the bots with command line / shell of various operating systems.\n\n\nFor more information, check \nour website\n.\n\n\nInstallation\n\n\nTry Kata Platform\n\n\nInstall Kata-CLI at your device, using this command:\n\n\n$ npm install -g kata-cli\n\n\n\n\nnow you can use command 'kata' globally\n\n\nCommands\n\n\nUse \nkata --help\n to see commands list available\n\n\n\n\nbot-init|init [options] <bot> <name> [version]\n - Init the bot\n\n\nbot-versions|versions\n - List versions of the bot\n\n\nbot-list|list-bots\n - List the bots\n\n\nbot-push|push [options]\n - Push the bot\n\n\nbot-delete|remove-bot\n - Delete selected bot\n\n\nbot-test|test [file]\n\n\nbot-console|console [options] <diaenneUrl>\n\n\ndeployment-deploy|deploy <name> [version]\n - Deploy the bot\n\n\ndeployment-addChannel|add-channel [options] <name> <channelName>\n - Add bot channel\n\n\ndeployment-removeChannel|remove-channel <name> <channelName>\n - Remove bot channel\n\n\ndeployment-drop|drop <name>\n\n\nsession-get <id> [deploymentId]\n\n\nsession-create [options] [id] [deploymentId]\n\n\nsession-update [options] <id> [deploymentId]\n\n\nsession-delete <id> [deploymentId]\n\n\nset <prop> <value>\n\n\nlogin [options] <type> [name]\n\n\n\n\nLogin\n\n\nTo start developing your bot,\nyou need to login using your account as user\n\n\n$ kata login user -u <username>\npassword: <password>\n\n\n\n\nLogin  using your account as team\n\n\n$ kata login team <teamName> -u <username>\npassword: <password>\n\n\n\n\nLogin using token\n\n\n$ kata login user -t <token>",
            "title": "Home"
        },
        {
            "location": "/#welcome-to-katadocs",
            "text": "",
            "title": "Welcome to KataDocs"
        },
        {
            "location": "/#introduction",
            "text": "Kata Command Line Interface (Kata CLI) is a tool for creating bots with\nKata Machine Learning (Kata ML) which suited with Natural Language Processing (NLP) technology.\nKata CLI also helps managing the bots with command line / shell of various operating systems.  For more information, check  our website .",
            "title": "Introduction"
        },
        {
            "location": "/#installation",
            "text": "",
            "title": "Installation"
        },
        {
            "location": "/#try-kata-platform",
            "text": "Install Kata-CLI at your device, using this command:  $ npm install -g kata-cli  now you can use command 'kata' globally",
            "title": "Try Kata Platform"
        },
        {
            "location": "/#commands",
            "text": "Use  kata --help  to see commands list available   bot-init|init [options] <bot> <name> [version]  - Init the bot  bot-versions|versions  - List versions of the bot  bot-list|list-bots  - List the bots  bot-push|push [options]  - Push the bot  bot-delete|remove-bot  - Delete selected bot  bot-test|test [file]  bot-console|console [options] <diaenneUrl>  deployment-deploy|deploy <name> [version]  - Deploy the bot  deployment-addChannel|add-channel [options] <name> <channelName>  - Add bot channel  deployment-removeChannel|remove-channel <name> <channelName>  - Remove bot channel  deployment-drop|drop <name>  session-get <id> [deploymentId]  session-create [options] [id] [deploymentId]  session-update [options] <id> [deploymentId]  session-delete <id> [deploymentId]  set <prop> <value>  login [options] <type> [name]",
            "title": "Commands"
        },
        {
            "location": "/#login",
            "text": "To start developing your bot,\nyou need to login using your account as user  $ kata login user -u <username>\npassword: <password>  Login  using your account as team  $ kata login team <teamName> -u <username>\npassword: <password>  Login using token  $ kata login user -t <token>",
            "title": "Login"
        },
        {
            "location": "/quickstart/",
            "text": "Quick Start\n\n\nHello Bot\n\n\nBefore started\n\nSimple explanation about the fundamental components of the bot consists of:\n\n\n\n\n nlu's \n: the natural language understanding/model, defined to be used in the bot\n\n\n intents \n : is list of purpose defined to understand user intention\n\n\n states \n : is the stages/procedure of interaction with user\n\n\n actions \n : is list of action defined to perform in each state \n\n\n methods \n : case of more complicated computation/action needed. In javascript language\n\n\n\n\nInit project\n\n\nCreate folder for your bot project, and init your bot there.\n\n\n$ mkdir <bot-folder>\n$ cd <bot-folder>\n$ kata init <bot-id> <bot-name> [version] #login not required to init bot\n\n\n\n\nthis will generate folder with \nnlu.yml, bot.yml, message.yml, flows folder\n\nexample:\n\n\nschema: kata.ai/schema/kata-ml/1.0\nname: <bot-name>\ndesc: Bot Description\nversion: <bot-version> #example 0.0.1\nflows:\n    fallback: $include(./flows/fallback.yml)\nconfig:\n    messages: $include(./messages.yml)\n    maxRecursion: 10\nnlus: $include(./nlu.yml)\nid: <bot-id>\n\n\n\n\nWriting Flow\n\n\nModify \nnlu.yml\n, to add handler for the next intent\n\n\nconfidenceLevel:\n    type: method\n    method: confidenceLevel\n\n# nlu greet will define input keyword hello, hallo, hai, and hi as hello\ngreet:\n    type: keyword\n    options:\n        keywords:\n            hello:\n                - hello\n                - hallo\n                - hai\n                - hi\n\n\n\n\nModify intents at \nflow/fallback.yml\n. \nMake 'hi' intents to use nlu 'greet' instead.\n\n\nhi:\n    initial: true\n    type: text\n    classifier:\n        nlu: greet\n\n\n\n\nFlow Explanation\n\n\n\n\nIntent will have value of 'hi' if input is caught by 'greet' NLU, and 'dunno' if no other intent caught by its classifier ('fallback: true' is like the default)\n\n\nAfter going to intents, next step is to go to states which have the value 'initial: true'.\n\n\nCase the input caught by 'hi' intents ('hello', hallo, etc).\n    'sayHi' transitions condition will be fulfilled, then at 'sayHi' transitions 'sayHi' actions will give text output from messages.yml with templates/sayHi's value\n\n\nCase the input not caught by any intent (will have 'dunno' as its intents).\n    'sorry' transitions condition as the default transitions from 'init' will be fulfilled, then at 'sorry' transitions 'saySorry' actions will give text output from messages.yml with templates/saySorry's value\n\n\n\n\nPush your Bot\n\n\n$ kata push --rev <patch | minor | major>\n\n\n\n\nDeployment\n\n\n$ kata deploy <name> [version]\n\n\n\n\nNOTE: Repeat push and deployment each time you want to update your bot at the messaging application\n\n\nAdding ChanneL\n\n\n$ kata add-channel [options] <name> <channelName> : ChannelId\ntype: <line | fbmessenger>\ntoken: <channel access token>\nrefreshToken : [refresToken] # may empty\nsecret: <channel secret>\nurl: <url> # Example: 'https://api.line.me' for LINE\n\n\n\n\nNOTE: adding channel only required \nONCE\n\n\nAdding webhook\n\n\nSetup webhook into url:\n\n\nhttps://kanal.kata.ai/receive_message/{channelId}\n\n\n\n\nNOTE: channelId generated from kata deployment-addChannel\n\n\nEXAMPLE: Create and Setup Bot Official Account (LINE)\n\n\n\n\nOpen Line Business web page\n\n\nChoose Messaging API, Start Using Developer Trial\n\n\nFill required information\n\n\nEnable API\n\n\nChoose Settings \u2192 Bot Settings, Allow use webhooks and open LINE Developers\n\n\nDon't forget to add Webhook URL\n\n\n\n\nPizza Bot (LINE)\n\n\nStep 1: Differentiate greet, and can't understand input\n\n\nStep 1.1: Defining nlu\n\n\nadd this in \nnlu.yml\n\n\n# model for entity recognition (example: person name, places, etc)\nner:\n  type: verstandTagger\n    options:\n      model: dcaca5ae-be7f-42f2-a6a1-2b250d4336fd\n\n# model for question, instruction, statement & greeting (qisg)        \nqisg:\n  type: verstandClassifier\n    options:\n      model: cb58d784-9e87-40d5-bae1-6077b934c061    \n\n# nlu for YES or NO statement\nyesno:\n  type: verstandClassifier\n    options:\n      model: b7df76e5-b95d-4925-9f86-2796ea85403a\n\n\n\n\nStep 1.2: Defining flows\n\n\nModify \nfallback.yml\n\n\n# case no other flow's intent caught something\nfallback: true\nintents:\n  fallbackIntent:\n      fallback: true\n\nstates:\n  init:\n    initial: true\n    transitions:\n      init:\n        fallback: true\n    action:\n      name: fallbackAction\n\nactions:\n  fallbackAction:\n    type: text\n    options:\n      text: \"Maaf, saya tidak mengerti.\"\n\n\n\n\nCreate \nwelcome.yml\n\n\npriority: 9\nintents:\n    greeting:\n        initial: true\n        type: text\n        classifier:\n            nlu: qisg\n            match: greeting\n        priority: 10\n\nstates:\n    init:\n        initial: true\n        transitions:\n          greet: \n            condition: \"intent == 'greeting'\"\n\n    greet:\n        end: true\n\n        # Normally it is tedious if we have to define a transition to a state that \n        # is available in every state. e.g. Cancel state. To mitigate this we can define \n        # a floating transition. The system will automatically attach this transition in \n        # every state.\n        float:\n            fallback: true\n        action:\n            - name: greetPerson\n              condition: \"!context.greetCount\"\n            - name: greetAgain\n              condition: \"context.greetCount >= 1\"\n\n        # Specify mapping or method to be executed when transition is started\n        # create context.greeCount or do increment\n        transit:\n            context.greetCount: \"intent == 'greeting' ? (context.greetCount || 0) + 1 : 0\"\n\nactions:\n    greetAgain:\n        type: text\n        options:\n            text: \"Hai mulu, buruan pesen dong\"\n\n    greetPerson:\n        type: text\n        options:\n            text: \"Halo pizza bot disini\"\n\n\n\n\nModify bot.yml\n\n\n# add flow of welcoming user\nflows:\n   welcome: $include(./flows/welcome.yml)\n   fallback: $include(./flows/fallback.yml)\n\n\n\n\nNow your bot able to tell if user is greeting, bot will response that it doesn't understand if user input anything other than greeting.\n\n\nStep 2: Bot can understand user's order\n\n\nAdd nlu at \nnlu.yml.\n\n\n# nlu for order a pizza based by keywords\norder:\n  type: keyword\n    options:\n      keywords:\n        pizzaOrder:\n          - pesan\n          - pesen\n          - beli\n          - pesen pizza\n          - pizza dong\n          - pizza\n\n\n\n\nnow create \norder.yml \ninside folder flows\n\n\nintents:\n  orderCommand:\n    initial: true\n    type: text\n    classifier:\n      nlu: order\n      match: pizzaOrder\n\nstates:\n  init:\n    initial: true\n    action:\n      - name: pizzaOptions\n      - name: askOptions\n    transitions:\n      init:\n        fallback: true\n\nactions:\n  pizzaOptions:\n    type: text\n    options:\n      text: 'Kami punya pilihan menu:\\n 1)Peperoni\\n 2)Ronipepe'\n\n  askOptions:\n    type: text\n    options:\n      text: 'Mau yang mana?'\n\n\n\n\ndont forget to modify flows in \nbot.yml\n\n\nflows:\n    welcome: $include(./flows/welcome.yml)\n    order: $include(./flows/order.yml) #add this line of code, to add order.yml into bot flow\n    fallback: $include(./flows/fallback.yml)\n\n\n\n\nNow the bot can have this following of conversation:\n\n\n$ user: 'Hai'\n- bot: 'Halo pizza bot disini'\n$ user: 'pesan pizza'\n- bot: 'Kami punya pilihan menu:\\n 1)Peperoni\\n 2)Ronipepe' \n- bot: 'Mau yang mana?'\n$ user: 'Halo'\n- bot: 'Hai mulu, buruan pesen dong'\n\n\n\n\n\n\nStep 3: Modify the text menu into carousel\n\n\nnow modify \norder.yml\n by adding pizzaOptions in actions\n\n\n# Example of hard-coded carousel\npizzaOptions:\n    type: \"template\"\n    options:\n        type: \"carousel\"\n        items:\n            - text: 'untuk penggemar bola pepe dan roni'\n              title: 'Pepperoni'\n              thumbnailImageUrl: <https image url>\n              actions:\n                - type: \"postback\"\n                  label: 'Pepperoni'\n                  payload: \n                    type: pizza\n                    pizza: pepperoni\n            - text: 'untuk pecinta ayam. Eaaaa'\n              title: 'Chick Lover'\n              thumbnailImageUrl: <https image url>\n              actions:\n                - type: \"postback\"\n                  label: 'Chick Lover'\n                  payload: \n                    type: pizza\n                    pizza: chicklover\n\n\n\n\nNow it should show carousel of menu instead of only text.\n\n\nStep 3.1: Use the input from carousel.\n\n\nNew intent needed to be able to catch input from carousel. Which the type is data, and payload content used to identify which carousel is being used (in case if there are more than 1 carousel or other input categorized as type data).\n\n\nAdd intents at \norder.yml.\n\n\n  # This will prevent intent caught by *fallbackIntent* at *fallback.yml*\n  pizzaChosen:\n    initial: true\n    type: data\n    condition: payload.type == 'pizza'\n\n  reenter:\n    type: command\n    condition: content == \"reenter\"\n\n\n\n\nAdd intents at \nwelcome.yml\n\n\nreenter:\n  type: command\n  condition: content == \"reenter\" \n\n\n\n\nremove the greet state and modify the init state\n\n\nstates:\n    init:\n        initial: true\n        transit:\n          context.greetCount: \"intent == 'greeting' ? (context.greetCount || 0) + 1 : 0\"\n        action:\n            - name: greetWOPerson\n              condition: \"!context.greetCount\"\n            - name: greetAgain\n              condition: \"context.greetCount >= 1\"\n        float:\n            fallback: true\n\n\n\n\nModify \ninit \nstates and add 2 other states at \norder.yml.\n\n\n  init:\n    initial: true\n    transitions:\n      showPizza:\n        condition: \"intent == 'orderCommand'\"\n      init:\n        fallback: true\n\n  showPizza:\n    action:\n      - name: pizzaOptions\n      - name: askOptions\n    transitions:\n      confirmPizza:\n        condition: \"intent == 'pizzaChosen'\"\n      showPizza:\n        fallback: true\n\n  confirmPizza:\n    end: true\n    action:\n      - name: confirmPizza\n    transitions:\n      confirmPizza:\n        fallback: true\n\n\n\n\nAdd actions di \norder.yml.\n\n\n  confirmPizza:\n    type: text\n    options:\n      text: \"Jadi benar pesanannya adalah $(payload.pizza)?\"\n\n\n\n\nThe bot can now understand the user input from carousel. \npayload\n is temporary, after some transitions it will have no value stored. later on we need to assign it to a \ncontext\n\n\n\n\nStep 4: Add flow until confirmation of the the order\n\n\nTwo state is added in this step, to know how many pizza that the user want to order and confirm if the user already order the right one. After confirmation the state will come back to initial state so the user can start order again.\n\n\nAdd nlu at \nnlu.yml\n\n\nquantity:\n    type: regex\n    options:\n        regex: \"[1-9]\"\n\n\n\n\nAdd intents at \norder.yml\n\n\n  pizzaQntty: \n    type: text\n    classifier:\n      nlu: quantity\n    attributes:\n      quantity:\n        nlu: quantity\n\n\n\n\nAdd and restructure the states in order.yml\n\n\nshowPizza:\n    action:\n      - name: pizzaOptions\n      - name: askOptions\n    transitions:\n      pizzaQuantity:\n        condition: \"intent == 'pizzaChosen'\"\n        mapping: \n          context.pizza: \"payload.pizza\" # remember payload.pizza for the whole session\n      showPizza:\n        fallback: true\n\n  pizzaQuantity:\n    action:\n      - name: askQuantity\n    transitions:\n      confirmPizza:\n        condition: \"intent == 'pizzaQntty'\"\n        mapping:\n          context.quantity: \"attributes.quantity\"\n          context.answer: \"null\"\n      pizzaQuantity:\n        fallback: true\n\n  confirmPizza:\n    action:\n      - name: confirmPizza\n    transitions:\n      done:\n        fallback: true\n    transit:\n        context.answer: \"intent\"\n\n  done:\n    end: true\n    action:\n      - name: sayThanks\n        condition: \"context.answer == 'yes'\"\n      - name: cancelOrder\n        condition: \"context.answer == 'no'\"\n\n\n\n\nAdd and modify actions at order.yml too\n\n\n askQuantity:\n    type: text\n    options:\n      text: 'Mau pesan berapa banyak? (Min.1 Max.9)'\n\n  confirmPizza:\n    type: text\n    options:\n      text: \"Jadi benar pesanannya adalah $(context.pizza)?\"\n\n  cancelOrder:\n    type: text\n    options:\n      text: \"Baiklah, silahkan pesan lagi di lain waktu\"\n\n  sayThanks:\n    type: text\n    options:\n      text: \"Terimakasih sudah memesan :)\"\n\n\n\n\n\n\nStep 5: Modify confirmation answer to button\n\n\nmodify the \norder.yml\n by adding the yesNoButton in actions\n\n\n  yesNoButton:\n    type: template\n    options:\n      type: button\n      items:\n        text: \"Benar pesanannya adalah $(context.pizza) sebanyak $(context.quantity)?\"\n        actions:\n          - type: postback\n            label: Ya\n            payload:\n              type: confirm\n              confirm: \"yes\"\n          - type: postback\n            label: Tidak\n            payload:\n              type: confirm\n              confirm: \"no\"\n\n\n\n\nStep 5.1: Use the input From Button\n\n\nAdd intent at \norder.yml\n\n\n  yesno:\n    type: data\n    condition: payload.type == 'confirm'\n\n\n\n\nmodify the \nconfirmPizza\n and \ninit\n state\n\n\n init:\n    initial: true\n    action:\n      - name: sayThanks\n        condition: \"context.answer == 'yes'\"\n      - name: cancelOrder\n        condition: \"context.answer == 'no'\"\n    transitions:\n      showPizza:\n        condition: \"intent == 'orderCommand'\"\n      init:\n        fallback: true\n\n  confirmPizza:\n    action:\n      - name: yesNoButton\n    transitions:\n      init:\n        fallback: true\n        mapping:\n          context.answer: \"payload.confirm\"\n    transit:\n        context.answer: \"intent\"  \n\n\n\n\nafter confirmation, at confirmPizza state it will return to init state and ready for another 'pesan' command.\n\n\n\nStep 6: Using LINE Sticker as bot response\n\n\nIn this step we want the bot to be able to give response to user with sticker, to identify what sticker will be used the packageId and stickerId is needed as argument in actions.\n\n\nadd action in \norder.yml\n\n\n  sayThanksSticker:\n    type: template\n    options:\n    type: sticker\n    items:\n      stickerId: '3'\n      packageId: '1'\n\n\n\n\nmodify init state in \norder.yml\n\n\n  init:\n    initial: true\n    action:\n      - name: sayThanks\n        condition: \"context.answer == 'yes'\"\n      - name: sayThanksSticker\n        condition: \"context.answer == 'yes'\"\n      - name: cancelOrder\n        condition: \"context.answer == 'no'\"\n    transitions:\n      showPizza:\n        condition: \"intent == 'orderCommand'\"\n      init:\n        fallback: true        \n\n\n\n\n\n\nStep 7: Using more dynamic carousel\n\n\nIn this step we want to create carousel but not each content is written specifically by developer, instead we can use JSON Object as its input.\n\n\nCreate methods in \norder.yml\n to simulate carousel which use JSON Object as input. The JSON Object example will be saved at \ncontext.arr\n when transit called \njalaninArr\n method.\n\n\nmethods:\n  jalaninArr(ctx): \"\n      ctx.context.arr = [{'item':'Chicken', 'desc':'chick lover'}, {'item':'Pepperoni', 'desc':'pepe rooney'}];\n      return ctx;\n  \"\n\n\n\n\nIn state \ninit\n at \norder.yml\n, add \ntransit \nso there will be \ncontext\n which contain JSON Object example\n\n\n    transit: jalaninArr\n\n\n\n\nAdd \nactions \nat \norder.yml\n, dynamic carousel actions which use JSON Object from methods \njalaninArr\n\n\n  pizzaOptionsDynamic:\n    type: template\n    options:\n      type: carousel\n      data: $(context.arr) # [{'item':\"Chicken\", 'desc':\"chick lover\"}, {'item':\"Pepperoni\", 'desc':\"pepe rooney\"}]\n      template:\n        text: $[desc]\n        title: $[item]\n        actions:\n          -  type: postback\n             label: $[item]\n             payload:\n               type: pizza\n               pizza: $[item]\n\n\n\n\nIn state \nshowPizza \nat \norder.yml\n, change action from \npizzaOptions \nto \npizzaOptionsDynamic\n\n\nshowPizza:\n    action:\n      - name: pizzaOptionsDynamic\n      - name: askOptions\n    transitions:\n      pizzaQuantity:\n        condition: \"intent == 'pizzaChosen'\"\n        mapping: \n          context.pizza: \"payload.pizza\"\n      showPizza:\n        fallback: true",
            "title": "Quick Start"
        },
        {
            "location": "/quickstart/#quick-start",
            "text": "",
            "title": "Quick Start"
        },
        {
            "location": "/quickstart/#hello-bot",
            "text": "Before started Simple explanation about the fundamental components of the bot consists of:    nlu's  : the natural language understanding/model, defined to be used in the bot   intents   : is list of purpose defined to understand user intention   states   : is the stages/procedure of interaction with user   actions   : is list of action defined to perform in each state    methods   : case of more complicated computation/action needed. In javascript language",
            "title": "Hello Bot"
        },
        {
            "location": "/quickstart/#init-project",
            "text": "Create folder for your bot project, and init your bot there.  $ mkdir <bot-folder>\n$ cd <bot-folder>\n$ kata init <bot-id> <bot-name> [version] #login not required to init bot  this will generate folder with  nlu.yml, bot.yml, message.yml, flows folder \nexample:  schema: kata.ai/schema/kata-ml/1.0\nname: <bot-name>\ndesc: Bot Description\nversion: <bot-version> #example 0.0.1\nflows:\n    fallback: $include(./flows/fallback.yml)\nconfig:\n    messages: $include(./messages.yml)\n    maxRecursion: 10\nnlus: $include(./nlu.yml)\nid: <bot-id>",
            "title": "Init project"
        },
        {
            "location": "/quickstart/#writing-flow",
            "text": "Modify  nlu.yml , to add handler for the next intent  confidenceLevel:\n    type: method\n    method: confidenceLevel\n\n# nlu greet will define input keyword hello, hallo, hai, and hi as hello\ngreet:\n    type: keyword\n    options:\n        keywords:\n            hello:\n                - hello\n                - hallo\n                - hai\n                - hi  Modify intents at  flow/fallback.yml . \nMake 'hi' intents to use nlu 'greet' instead.  hi:\n    initial: true\n    type: text\n    classifier:\n        nlu: greet  Flow Explanation   Intent will have value of 'hi' if input is caught by 'greet' NLU, and 'dunno' if no other intent caught by its classifier ('fallback: true' is like the default)  After going to intents, next step is to go to states which have the value 'initial: true'.  Case the input caught by 'hi' intents ('hello', hallo, etc).\n    'sayHi' transitions condition will be fulfilled, then at 'sayHi' transitions 'sayHi' actions will give text output from messages.yml with templates/sayHi's value  Case the input not caught by any intent (will have 'dunno' as its intents).\n    'sorry' transitions condition as the default transitions from 'init' will be fulfilled, then at 'sorry' transitions 'saySorry' actions will give text output from messages.yml with templates/saySorry's value",
            "title": "Writing Flow"
        },
        {
            "location": "/quickstart/#push-your-bot",
            "text": "$ kata push --rev <patch | minor | major>",
            "title": "Push your Bot"
        },
        {
            "location": "/quickstart/#deployment",
            "text": "$ kata deploy <name> [version]  NOTE: Repeat push and deployment each time you want to update your bot at the messaging application",
            "title": "Deployment"
        },
        {
            "location": "/quickstart/#adding-channel",
            "text": "$ kata add-channel [options] <name> <channelName> : ChannelId\ntype: <line | fbmessenger>\ntoken: <channel access token>\nrefreshToken : [refresToken] # may empty\nsecret: <channel secret>\nurl: <url> # Example: 'https://api.line.me' for LINE  NOTE: adding channel only required  ONCE",
            "title": "Adding ChanneL"
        },
        {
            "location": "/quickstart/#adding-webhook",
            "text": "Setup webhook into url:  https://kanal.kata.ai/receive_message/{channelId}  NOTE: channelId generated from kata deployment-addChannel",
            "title": "Adding webhook"
        },
        {
            "location": "/quickstart/#example-create-and-setup-bot-official-account-line",
            "text": "Open Line Business web page  Choose Messaging API, Start Using Developer Trial  Fill required information  Enable API  Choose Settings \u2192 Bot Settings, Allow use webhooks and open LINE Developers  Don't forget to add Webhook URL",
            "title": "EXAMPLE: Create and Setup Bot Official Account (LINE)"
        },
        {
            "location": "/quickstart/#pizza-bot-line",
            "text": "",
            "title": "Pizza Bot (LINE)"
        },
        {
            "location": "/quickstart/#step-1-differentiate-greet-and-cant-understand-input",
            "text": "",
            "title": "Step 1: Differentiate greet, and can't understand input"
        },
        {
            "location": "/quickstart/#step-11-defining-nlu",
            "text": "add this in  nlu.yml  # model for entity recognition (example: person name, places, etc)\nner:\n  type: verstandTagger\n    options:\n      model: dcaca5ae-be7f-42f2-a6a1-2b250d4336fd\n\n# model for question, instruction, statement & greeting (qisg)        \nqisg:\n  type: verstandClassifier\n    options:\n      model: cb58d784-9e87-40d5-bae1-6077b934c061    \n\n# nlu for YES or NO statement\nyesno:\n  type: verstandClassifier\n    options:\n      model: b7df76e5-b95d-4925-9f86-2796ea85403a",
            "title": "Step 1.1: Defining nlu"
        },
        {
            "location": "/quickstart/#step-12-defining-flows",
            "text": "Modify  fallback.yml  # case no other flow's intent caught something\nfallback: true\nintents:\n  fallbackIntent:\n      fallback: true\n\nstates:\n  init:\n    initial: true\n    transitions:\n      init:\n        fallback: true\n    action:\n      name: fallbackAction\n\nactions:\n  fallbackAction:\n    type: text\n    options:\n      text: \"Maaf, saya tidak mengerti.\"  Create  welcome.yml  priority: 9\nintents:\n    greeting:\n        initial: true\n        type: text\n        classifier:\n            nlu: qisg\n            match: greeting\n        priority: 10\n\nstates:\n    init:\n        initial: true\n        transitions:\n          greet: \n            condition: \"intent == 'greeting'\"\n\n    greet:\n        end: true\n\n        # Normally it is tedious if we have to define a transition to a state that \n        # is available in every state. e.g. Cancel state. To mitigate this we can define \n        # a floating transition. The system will automatically attach this transition in \n        # every state.\n        float:\n            fallback: true\n        action:\n            - name: greetPerson\n              condition: \"!context.greetCount\"\n            - name: greetAgain\n              condition: \"context.greetCount >= 1\"\n\n        # Specify mapping or method to be executed when transition is started\n        # create context.greeCount or do increment\n        transit:\n            context.greetCount: \"intent == 'greeting' ? (context.greetCount || 0) + 1 : 0\"\n\nactions:\n    greetAgain:\n        type: text\n        options:\n            text: \"Hai mulu, buruan pesen dong\"\n\n    greetPerson:\n        type: text\n        options:\n            text: \"Halo pizza bot disini\"  Modify bot.yml  # add flow of welcoming user\nflows:\n   welcome: $include(./flows/welcome.yml)\n   fallback: $include(./flows/fallback.yml)  Now your bot able to tell if user is greeting, bot will response that it doesn't understand if user input anything other than greeting.",
            "title": "Step 1.2: Defining flows"
        },
        {
            "location": "/quickstart/#step-2-bot-can-understand-users-order",
            "text": "Add nlu at  nlu.yml.  # nlu for order a pizza based by keywords\norder:\n  type: keyword\n    options:\n      keywords:\n        pizzaOrder:\n          - pesan\n          - pesen\n          - beli\n          - pesen pizza\n          - pizza dong\n          - pizza  now create  order.yml  inside folder flows  intents:\n  orderCommand:\n    initial: true\n    type: text\n    classifier:\n      nlu: order\n      match: pizzaOrder\n\nstates:\n  init:\n    initial: true\n    action:\n      - name: pizzaOptions\n      - name: askOptions\n    transitions:\n      init:\n        fallback: true\n\nactions:\n  pizzaOptions:\n    type: text\n    options:\n      text: 'Kami punya pilihan menu:\\n 1)Peperoni\\n 2)Ronipepe'\n\n  askOptions:\n    type: text\n    options:\n      text: 'Mau yang mana?'  dont forget to modify flows in  bot.yml  flows:\n    welcome: $include(./flows/welcome.yml)\n    order: $include(./flows/order.yml) #add this line of code, to add order.yml into bot flow\n    fallback: $include(./flows/fallback.yml)  Now the bot can have this following of conversation:  $ user: 'Hai'\n- bot: 'Halo pizza bot disini'\n$ user: 'pesan pizza'\n- bot: 'Kami punya pilihan menu:\\n 1)Peperoni\\n 2)Ronipepe' \n- bot: 'Mau yang mana?'\n$ user: 'Halo'\n- bot: 'Hai mulu, buruan pesen dong'",
            "title": "Step 2: Bot can understand user's order"
        },
        {
            "location": "/quickstart/#step-3-modify-the-text-menu-into-carousel",
            "text": "now modify  order.yml  by adding pizzaOptions in actions  # Example of hard-coded carousel\npizzaOptions:\n    type: \"template\"\n    options:\n        type: \"carousel\"\n        items:\n            - text: 'untuk penggemar bola pepe dan roni'\n              title: 'Pepperoni'\n              thumbnailImageUrl: <https image url>\n              actions:\n                - type: \"postback\"\n                  label: 'Pepperoni'\n                  payload: \n                    type: pizza\n                    pizza: pepperoni\n            - text: 'untuk pecinta ayam. Eaaaa'\n              title: 'Chick Lover'\n              thumbnailImageUrl: <https image url>\n              actions:\n                - type: \"postback\"\n                  label: 'Chick Lover'\n                  payload: \n                    type: pizza\n                    pizza: chicklover  Now it should show carousel of menu instead of only text.",
            "title": "Step 3: Modify the text menu into carousel"
        },
        {
            "location": "/quickstart/#step-31-use-the-input-from-carousel",
            "text": "New intent needed to be able to catch input from carousel. Which the type is data, and payload content used to identify which carousel is being used (in case if there are more than 1 carousel or other input categorized as type data).  Add intents at  order.yml.    # This will prevent intent caught by *fallbackIntent* at *fallback.yml*\n  pizzaChosen:\n    initial: true\n    type: data\n    condition: payload.type == 'pizza'\n\n  reenter:\n    type: command\n    condition: content == \"reenter\"  Add intents at  welcome.yml  reenter:\n  type: command\n  condition: content == \"reenter\"   remove the greet state and modify the init state  states:\n    init:\n        initial: true\n        transit:\n          context.greetCount: \"intent == 'greeting' ? (context.greetCount || 0) + 1 : 0\"\n        action:\n            - name: greetWOPerson\n              condition: \"!context.greetCount\"\n            - name: greetAgain\n              condition: \"context.greetCount >= 1\"\n        float:\n            fallback: true  Modify  init  states and add 2 other states at  order.yml.    init:\n    initial: true\n    transitions:\n      showPizza:\n        condition: \"intent == 'orderCommand'\"\n      init:\n        fallback: true\n\n  showPizza:\n    action:\n      - name: pizzaOptions\n      - name: askOptions\n    transitions:\n      confirmPizza:\n        condition: \"intent == 'pizzaChosen'\"\n      showPizza:\n        fallback: true\n\n  confirmPizza:\n    end: true\n    action:\n      - name: confirmPizza\n    transitions:\n      confirmPizza:\n        fallback: true  Add actions di  order.yml.    confirmPizza:\n    type: text\n    options:\n      text: \"Jadi benar pesanannya adalah $(payload.pizza)?\"  The bot can now understand the user input from carousel.  payload  is temporary, after some transitions it will have no value stored. later on we need to assign it to a  context",
            "title": "Step 3.1: Use the input from carousel."
        },
        {
            "location": "/quickstart/#step-4-add-flow-until-confirmation-of-the-the-order",
            "text": "Two state is added in this step, to know how many pizza that the user want to order and confirm if the user already order the right one. After confirmation the state will come back to initial state so the user can start order again.  Add nlu at  nlu.yml  quantity:\n    type: regex\n    options:\n        regex: \"[1-9]\"  Add intents at  order.yml    pizzaQntty: \n    type: text\n    classifier:\n      nlu: quantity\n    attributes:\n      quantity:\n        nlu: quantity  Add and restructure the states in order.yml  showPizza:\n    action:\n      - name: pizzaOptions\n      - name: askOptions\n    transitions:\n      pizzaQuantity:\n        condition: \"intent == 'pizzaChosen'\"\n        mapping: \n          context.pizza: \"payload.pizza\" # remember payload.pizza for the whole session\n      showPizza:\n        fallback: true\n\n  pizzaQuantity:\n    action:\n      - name: askQuantity\n    transitions:\n      confirmPizza:\n        condition: \"intent == 'pizzaQntty'\"\n        mapping:\n          context.quantity: \"attributes.quantity\"\n          context.answer: \"null\"\n      pizzaQuantity:\n        fallback: true\n\n  confirmPizza:\n    action:\n      - name: confirmPizza\n    transitions:\n      done:\n        fallback: true\n    transit:\n        context.answer: \"intent\"\n\n  done:\n    end: true\n    action:\n      - name: sayThanks\n        condition: \"context.answer == 'yes'\"\n      - name: cancelOrder\n        condition: \"context.answer == 'no'\"  Add and modify actions at order.yml too   askQuantity:\n    type: text\n    options:\n      text: 'Mau pesan berapa banyak? (Min.1 Max.9)'\n\n  confirmPizza:\n    type: text\n    options:\n      text: \"Jadi benar pesanannya adalah $(context.pizza)?\"\n\n  cancelOrder:\n    type: text\n    options:\n      text: \"Baiklah, silahkan pesan lagi di lain waktu\"\n\n  sayThanks:\n    type: text\n    options:\n      text: \"Terimakasih sudah memesan :)\"",
            "title": "Step 4: Add flow until confirmation of the the order"
        },
        {
            "location": "/quickstart/#step-5-modify-confirmation-answer-to-button",
            "text": "modify the  order.yml  by adding the yesNoButton in actions    yesNoButton:\n    type: template\n    options:\n      type: button\n      items:\n        text: \"Benar pesanannya adalah $(context.pizza) sebanyak $(context.quantity)?\"\n        actions:\n          - type: postback\n            label: Ya\n            payload:\n              type: confirm\n              confirm: \"yes\"\n          - type: postback\n            label: Tidak\n            payload:\n              type: confirm\n              confirm: \"no\"",
            "title": "Step 5: Modify confirmation answer to button"
        },
        {
            "location": "/quickstart/#step-51-use-the-input-from-button",
            "text": "Add intent at  order.yml    yesno:\n    type: data\n    condition: payload.type == 'confirm'  modify the  confirmPizza  and  init  state   init:\n    initial: true\n    action:\n      - name: sayThanks\n        condition: \"context.answer == 'yes'\"\n      - name: cancelOrder\n        condition: \"context.answer == 'no'\"\n    transitions:\n      showPizza:\n        condition: \"intent == 'orderCommand'\"\n      init:\n        fallback: true\n\n  confirmPizza:\n    action:\n      - name: yesNoButton\n    transitions:\n      init:\n        fallback: true\n        mapping:\n          context.answer: \"payload.confirm\"\n    transit:\n        context.answer: \"intent\"    after confirmation, at confirmPizza state it will return to init state and ready for another 'pesan' command.",
            "title": "Step 5.1: Use the input From Button"
        },
        {
            "location": "/quickstart/#step-6-using-line-sticker-as-bot-response",
            "text": "In this step we want the bot to be able to give response to user with sticker, to identify what sticker will be used the packageId and stickerId is needed as argument in actions.  add action in  order.yml    sayThanksSticker:\n    type: template\n    options:\n    type: sticker\n    items:\n      stickerId: '3'\n      packageId: '1'  modify init state in  order.yml    init:\n    initial: true\n    action:\n      - name: sayThanks\n        condition: \"context.answer == 'yes'\"\n      - name: sayThanksSticker\n        condition: \"context.answer == 'yes'\"\n      - name: cancelOrder\n        condition: \"context.answer == 'no'\"\n    transitions:\n      showPizza:\n        condition: \"intent == 'orderCommand'\"\n      init:\n        fallback: true",
            "title": "Step 6: Using LINE Sticker as bot response"
        },
        {
            "location": "/quickstart/#step-7-using-more-dynamic-carousel",
            "text": "In this step we want to create carousel but not each content is written specifically by developer, instead we can use JSON Object as its input.  Create methods in  order.yml  to simulate carousel which use JSON Object as input. The JSON Object example will be saved at  context.arr  when transit called  jalaninArr  method.  methods:\n  jalaninArr(ctx): \"\n      ctx.context.arr = [{'item':'Chicken', 'desc':'chick lover'}, {'item':'Pepperoni', 'desc':'pepe rooney'}];\n      return ctx;\n  \"  In state  init  at  order.yml , add  transit  so there will be  context  which contain JSON Object example      transit: jalaninArr  Add  actions  at  order.yml , dynamic carousel actions which use JSON Object from methods  jalaninArr    pizzaOptionsDynamic:\n    type: template\n    options:\n      type: carousel\n      data: $(context.arr) # [{'item':\"Chicken\", 'desc':\"chick lover\"}, {'item':\"Pepperoni\", 'desc':\"pepe rooney\"}]\n      template:\n        text: $[desc]\n        title: $[item]\n        actions:\n          -  type: postback\n             label: $[item]\n             payload:\n               type: pizza\n               pizza: $[item]  In state  showPizza  at  order.yml , change action from  pizzaOptions  to  pizzaOptionsDynamic  showPizza:\n    action:\n      - name: pizzaOptionsDynamic\n      - name: askOptions\n    transitions:\n      pizzaQuantity:\n        condition: \"intent == 'pizzaChosen'\"\n        mapping: \n          context.pizza: \"payload.pizza\"\n      showPizza:\n        fallback: true",
            "title": "Step 7: Using more dynamic carousel"
        }
    ]
}